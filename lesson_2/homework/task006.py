# F. Колесо Фортуны
# Ограничение времени 1 секунда Ограничение памяти 64Mb
#
# Ввод стандартный ввод или input.txt Вывод стандартный вывод или output.txt
#
# Развлекательный телеканал транслирует шоу «Колесо Фортуны». В процессе игры участники шоу крутят большое колесо,
# разделенное на сектора. В каждом секторе этого колеса записано число. После того как колесо останавливается,
# специальная стрелка указывает на один из секторов. Число в этом секторе определяет выигрыш игрока.
#
# Юный участник шоу заметил, что колесо в процессе вращения замедляется из-за того, что стрелка задевает за выступы на
# колесе, находящиеся между секторами. Если колесо вращается с угловой скоростью v градусов в секунду, и стрелка,
# переходя из сектора X к следующему сектору, задевает за очередной выступ, то текущая угловая скорость движения
# колеса уменьшается на k градусов в секунду. При этом если v ≤ k, то колесо не может преодолеть препятствие и
# останавливается. Стрелка в этом случае будет указывать на сектор X.
# ![](./1.png)
# Юный участник шоу собирается вращать колесо. Зная порядок секторов на колесе, он хочет заставить колесо вращаться с
# такой начальной скоростью, чтобы после остановки колеса стрелка указала на как можно большее число. Колесо можно
# вращать в любом направлении и придавать ему начальную угловую скорость от a до b градусов в секунду.
#
# Требуется написать программу, которая по заданному расположению чисел в секторах, минимальной и максимальной
# начальной угловой скорости вращения колеса и величине замедления колеса при переходе через границу секторов
# вычисляет максимальный выигрыш.
#
# Формат ввода
#
# Первая строка входного файла содержит целое число n — количество секторов колеса (3 ≤ n ≤ 100).
#
# Вторая строка входного файла содержит n положительных целых чисел, каждое из которых не превышает 1000 — числа,
# записанные в секторах колеса. Числа приведены в порядке следования секторов по часовой стрелке.
# Изначально стрелка указывает на первое число.
#
# Третья строка содержит три целых числа: a, b и k (1 ≤ a ≤ b ≤ 109, 1 ≤ k ≤ 109).
#
# Формат вывода
#
# В выходном файле должно содержаться одно целое число — максимальный выигрыш.
#
# Пример 1
# Ввод
# 5
# 1 2 3 4 5
# 3 5 2
# Вывод
# 5
# Пример 2
# Ввод
# 5
# 1 2 3 4 5
# 15 15 2
# Вывод
# 4
# Пример 3
# Ввод
# 5
# 5 4 3 2 1
# 2 5 2
# Вывод
# 5
#
# Примечания
#
# В первом примере возможны следующие варианты: можно придать начальную скорость колесу равную 3 или 4, что приведет к
# тому, что стрелка преодолеет одну границу между секторами, или придать начальную скорость равную 5, что позволит стрелке
# преодолеть 2 границы между секторами. В первом варианте, если закрутить колесо в одну сторону, то выигрыш получится
# равным 2, а если закрутить его в противоположную сторону, то — 5. Во втором варианте, если закрутить колесо в одну
# сторону, то выигрыш будет равным 3, а если в другую сторону, то — 4.
#
# Во втором примере возможна только одна начальная скорость вращения колеса — 15 градусов в секунду. В этом случае при
# вращении колеса стрелка преодолеет семь границ между секторами. Тогда если его закрутить в одном направлении, то выигрыш
# составит 4, а если в противоположном направлении, то — 3.
#
# Наконец, в третьем примере оптимальная начальная скорость вращения колеса равна 2 градусам в секунду. В этом случае
# стрелка вообще не сможет преодолеть границу между секторами, и выигрыш будет равен 5.

def calculate_shift_max(a, b, k, n, scores):
    Vmax = max(a, b)
    shift_max = max(0, (Vmax - 1) // k) % n
    return shift_max


def calculate_shift_min(a, b, k, n, scores):
    Vmin = min(a, b)
    shift_min = max(0, (Vmin - 1) // k) % n
    return shift_min


def calculate_all_range_available_flag(shift_min, shift_max, n, Vmin, Vmax, k):
    all_range_available_flag = 0
    if (((Vmax - 1) // k) - ((Vmin - 1) // k)) >= n:
        all_range_available_flag = 1
    return all_range_available_flag


def calculate_shift_list_1(scores, shift_min, shift_max, n, all_range_available_flag):
    shift_list_1 = set()
    if all_range_available_flag == 1:
        shift_list_1 = set().union(scores)
    elif shift_max > shift_min:
        shift_list_1 = set().union(scores[shift_min:shift_max + 1])
    elif shift_max < shift_min:
        shift_list_1 = set().union(scores[0:shift_max + 1])
        shift_list_1 = shift_list_1.union(scores[shift_min:])
    else:
        shift_list_1.add(scores[shift_max])
    return shift_list_1


def calculate_shift_list_2(scores, shift_min, shift_max, n):
    shift_list_2 = set()
    if (n + 1 - shift_max) < (n + 1 - shift_min):
        shift_list_2 = set().union(scores[n - shift_max:n - shift_min + 1])
    elif (n + 1 - shift_max) > (n + 1 - shift_min):
        shift_list_2 = set().union(scores[0:n - shift_min])
        shift_list_2 = shift_list_2.union(scores[n - shift_max:])
    else:
        shift_list_2.add(scores[(n - shift_max) % n])
    return shift_list_2


def main():
    n = int(input())
    scores = [i for i in map(int, input().split())]
    a, b, k = map(int, input().split())

    Vmax = max(a, b)
    Vmin = min(a, b)

    shift_max = calculate_shift_max(a, b, k, n, scores)
    shift_min = calculate_shift_min(a, b, k, n, scores)

    all_range_available_flag = calculate_all_range_available_flag(shift_min, shift_max, n, Vmin, Vmax, k)

    shift_list_1 = calculate_shift_list_1(scores, shift_min, shift_max, n, all_range_available_flag)
    shift_list_2 = calculate_shift_list_2(scores, shift_min, shift_max, n)

    total_set = shift_list_1.union(shift_list_2)

    max_score = max(total_set)

    print(max_score)


if __name__ == "__main__":
    main()
# ok
