# H. Спички детям не игрушка!
# Ограничение времени	3 секунды
# Ограничение памяти	256Mb
# Ввод	стандартный ввод или input.txt
# Вывод	стандартный вывод или output.txt
# Вася любит решать головоломки со спичками. Чаще всего они формулируется следующим образом: дано изображение A,
# составленное из спичек; переложите в нем минимальное количество спичек так, чтобы получилось изображение B.
#
# Например, из номера текущего командного чемпионата школьников Санкт-Петербурга по программированию, можно получить
# ромб с диагональю, переложив всего три спички.
#
#
# Головоломки, которые решает Вася, всегда имеют решение. Это значит, что набор спичек, используемый в изображении A,
# совпадает с набором спичек, используемым в изображении B. Кроме того, в одном изображении никогда не встречаются две
# спички, у которых есть общий участок ненулевой длины (то есть спички могут пересекаться, но не могут накладываться
# друг на друга).
#
# Вася устал решать головоломки вручную, и теперь он просит вас написать, программу, которая будет решать
# головоломки за него. Программа будет получать описания изображений A и B и должна найти минимальное количество
# спичек, которые надо переложить в изображении A, чтобы полученная картинка получалась из B параллельным переносом.
#
# Формат ввода
# В первой строке входного файла содержится целое число n — количество спичек в каждом из изображений (1 ≤ n ≤ 1000).
#
# В следующих n строках записаны координаты концов спичек на изображении A. Спичка номер i описывается
# целыми числами x1i, y1i, x2i, y2i — координатами ее концов. Следующие n строк содержат описание изображения
# B в таком же формате. Набор длин этих спичек совпадает с набором длин спичек с изображения A.
#
# Все координаты по абсолютной величине не превосходят 104. Все спички имеют ненулевую длину,
# то есть x1i ≠ x2i или y1i ≠ y2i.
#
# Формат вывода
# Выведите в выходной файл минимальное количество спичек, которые следует переложить, чтобы изображение A
# совпало с изображением B, с точностью до параллельного переноса.
#
# Пример 1
# Ввод
# 5
# 0 0 1 2
# 1 0 0 2
# 2 0 2 2
# 4 0 3 2
# 4 0 5 2
# 9 -1 10 1
# 10 1 9 3
# 8 1 10 1
# 8 1 9 -1
# 8 1 9 3
# Вывод
# 3
# Пример 2
# Ввод
# 1
# 3 4 7 9
# -1 3 3 8
# Вывод
# 0
# Пример 3
# Ввод
# 1
# -4 5 2 -3
# -12 4 -2 4
# Вывод
# 1
with open("./input.txt") as in_file:
    N = int(in_file.readline())

    map1 = {}
    map2 = {}

    for _ in range(N):
        data = list(map(int, in_file.readline().split()))

        vec = (data[2] - data[0], data[3] - data[1])
        sm = (data[2], data[3])

        vec1 = (data[0] - data[2], data[1] - data[3])
        sm1 = (data[0], data[1])

        map1[vec] = sm
        map1[vec1] = sm1

    for _ in range(N):
        data = list(map(int, in_file.readline().split()))

        vec = (data[2] - data[0], data[3] - data[1])
        sm = (data[2], data[3])

        vec1 = (data[0] - data[2], data[1] - data[3])
        sm1 = (data[0], data[1])

        map2[vec] = sm
        map2[vec1] = sm1

smesh = set()
counter = {}

for item1 in map1.items():
    for item2 in map2.items():
        if item1[0] == item2[0]:
            temp = (item2[1][0] - item1[1][0], item2[1][1] - item1[1][1])
            if temp in smesh:
                counter[temp] = counter.get(temp, 0) + 1
            else:
                smesh.add(temp)
                counter[temp] = 1

pr = max(counter.items(), key=lambda x: x[1], default=(None, 0))

if not counter:
    print(N)
else:
    print(N - pr[1] // 2)
# На python ошибка, сдал на C++
